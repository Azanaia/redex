/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "RClass.h"

#include <string>

#include "ControlFlow.h"
#include "DexInstruction.h"
#include "DexUtil.h"
#include "GlobalConfig.h"
#include "LiveRange.h"
#include "RedexResources.h"
#include "Resolver.h"
#include "ScopedCFG.h"
#include "Show.h"

namespace {
// Crude check for if the name matches the pattern of autogenerated R class.
bool is_resource_class_name(const std::string_view& cls_name) {
  return cls_name.find("/R$") != std::string::npos;
}

// See
// https://github.com/facebook/buck/blob/main/src/com/facebook/buck/android/MergeAndroidResourcesStep.java#L385
// https://github.com/facebook/buck/commit/ec583c559239256ba0478d4bfdfc8d2c21426c4b
bool is_customized_resource_class_name(
    const std::string_view& cls_name,
    const ResourceConfig& global_resource_config) {
  // std::string name(cls_name);
  // return global_resource_config.customized_r_classes.count(name) > 0;
  for (const auto& s : global_resource_config.customized_r_classes) {
    if (cls_name == s) {
      return true;
    }
  }
  return false;
}
} // namespace

namespace resources {
// TODO: move away from this function
bool is_r_class(const DexClass* cls) {
  const auto c_name = cls->get_name()->str();
  const auto d_name = cls->get_deobfuscated_name_or_empty();
  return is_resource_class_name(c_name) || is_resource_class_name(d_name);
}

bool RClassReader::is_r_class(const DexClass* cls) const {
  const auto c_name = cls->get_name()->str();
  const auto d_name = cls->get_deobfuscated_name_or_empty();
  return is_resource_class_name(c_name) || is_resource_class_name(d_name) ||
         is_customized_resource_class_name(c_name, m_global_resources_config) ||
         is_customized_resource_class_name(d_name, m_global_resources_config);
}

void RClassReader::extract_resource_ids_from_static_arrays(
    const std::unordered_set<DexField*>& array_fields,
    std::unordered_set<uint32_t>* out_values) const {
  // TODO: Improve this piece of analysis to lift restriction of having to run
  // the pass before ReduceArrayLiteralsPass and
  // InstructionSequenceOutlinerPass.
  std::unordered_set<DexClass*> classes_to_search;
  for (DexField* field : array_fields) {
    DexClass* clazz = type_class(field->get_class());

    // We can assert a non-null class since we know these fields came
    // from classes we iterated over.
    always_assert(clazz != nullptr);
    classes_to_search.emplace(clazz);
  }

  for (auto clazz : classes_to_search) {
    DexMethod* clinit = clazz->get_clinit();
    IRCode* ir_code = clinit->get_code();
    if (ir_code == nullptr) {
      continue;
    }
    always_assert(ir_code->editable_cfg_built());
    auto& cfg = ir_code->cfg();
    live_range::MoveAwareChains move_aware_chains(cfg);
    auto use_defs = move_aware_chains.get_use_def_chains();
    auto def_uses = move_aware_chains.get_def_use_chains();
    for (const auto& mie : InstructionIterable(cfg)) {
      auto insn = mie.insn;
      if (!opcode::is_an_sput(insn->opcode())) {
        continue;
      }
      auto field = resolve_field(insn->get_field(), FieldSearch::Static);
      // Only consider array values for the requested fields.
      if (!array_fields.count(field)) {
        continue;
      }
      std::unordered_set<uint32_t> inner_array_values;
      auto& array_defs = use_defs.at(live_range::Use{insn, 0});
      // should be only one, but we can be conservative and consider all
      for (auto* array_def : array_defs) {
        auto& uses = def_uses.at(array_def);
        if (array_def->opcode() == OPCODE_SGET_OBJECT && uses.size() == 1) {
          continue;
        }
        always_assert_log(array_def->opcode() == OPCODE_NEW_ARRAY,
                          "OptimizeResources does not support extracting "
                          "resources from array created by %s\nin %s:\n%s",
                          SHOW(array_def), SHOW(clinit), SHOW(cfg));
        // should be only one, but we can be conservative and consider all
        for (auto& use : uses) {
          switch (use.insn->opcode()) {
          case OPCODE_FILL_ARRAY_DATA: {
            always_assert(use.src_index == 0);
            auto array_ints =
                get_fill_array_data_payload<uint32_t>(use.insn->get_data());
            for (uint32_t entry_x : array_ints) {
              if (entry_x > PACKAGE_RESID_START) {
                inner_array_values.emplace(entry_x);
              }
            }
            break;
          }
          case OPCODE_APUT: {
            always_assert(use.src_index == 1);
            auto value_defs = use_defs.at(live_range::Use{use.insn, 0});
            for (auto* value_def : value_defs) {
              always_assert_log(value_def->opcode() == OPCODE_CONST,
                                "OptimizeResources does not support extracting "
                                "resources from value given by %s",
                                SHOW(value_def));
              auto const_literal = value_def->get_literal();
              if (const_literal > PACKAGE_RESID_START) {
                inner_array_values.emplace(const_literal);
              }
            }
            break;
          }
          default:
            if (use.insn != insn) {
              always_assert_log(false,
                                "OptimizeResources does not support extracting "
                                "resources from array escaping via %s",
                                SHOW(use.insn));
            }
            break;
          }
        }
      }
      out_values->insert(inner_array_values.begin(), inner_array_values.end());
    }
  }
}
} // namespace resources
